{
  "0": {
    "question": "Which synchronization method is the most efficient in terms of CPU processing time?",
    "ground_truth": "The proposed method compared to state-based and delta-based methods.",
    "selected_figures": [
      "1803.02750v3-Figure1-1.png",
      "1803.02750v3-TableI-1.png",
      "1803.02750v3-Figure6-1.png",
      "1803.02750v3-Figure7-1.png",
      "1803.02750v3-Figure13-1.png",
      "1803.02750v3-Figure2-1.png",
      "1803.02750v3-Figure3-1.png",
      "1803.02750v3-Figure8-1.png",
      "1803.02750v3-Figure4-1.png",
      "1803.02750v3-Figure5-1.png",
      "1803.02750v3-Figure9-1.png",
      "1803.02750v3-Figure10-1.png",
      "1803.02750v3-TableIII-1.png",
      "1803.02750v3-TableIV-1.png",
      "1803.02750v3-Figure12-1.png"
    ],
    "answer": "Delta-based synchronization of a GSet with 2 replicas A,B \u2208 I. Underlined elements represent the BP optimization. <s>"
  },
  "1": {
    "question": "What is the difference between GCounter and GSet?",
    "ground_truth": "GCounter measures the number of times an event has occurred, while GSet measures the number of unique elements in a set.",
    "selected_figures": [
      "1803.02750v3-Figure1-1.png",
      "1803.02750v3-TableI-1.png",
      "1803.02750v3-Figure6-1.png",
      "1803.02750v3-Figure7-1.png",
      "1803.02750v3-Figure13-1.png",
      "1803.02750v3-Figure2-1.png",
      "1803.02750v3-Figure3-1.png",
      "1803.02750v3-Figure8-1.png",
      "1803.02750v3-Figure4-1.png",
      "1803.02750v3-Figure5-1.png",
      "1803.02750v3-Figure9-1.png",
      "1803.02750v3-Figure10-1.png",
      "1803.02750v3-TableII-1.png",
      "1803.02750v3-TableIII-1.png",
      "1803.02750v3-TableIV-1.png",
      "1803.02750v3-Figure12-1.png"
    ],
    "answer": "GCounter and GSet are two different data structures used in Distributed Computing Concepts (DCC). GCounter is a counter that maintains a count of the number of occurrences of a given event, while GSet is a set that maintains a collection of unique elements. <s>"
  },
  "2": {
    "question": "Which of the algorithms is most efficient in terms of transmission in a tree topology?",
    "ground_truth": "Op-based GSet.",
    "selected_figures": [
      "1803.02750v3-Figure1-1.png",
      "1803.02750v3-TableI-1.png",
      "1803.02750v3-Figure6-1.png",
      "1803.02750v3-Figure7-1.png",
      "1803.02750v3-Figure13-1.png",
      "1803.02750v3-Figure2-1.png",
      "1803.02750v3-Figure3-1.png",
      "1803.02750v3-Figure8-1.png",
      "1803.02750v3-Figure4-1.png",
      "1803.02750v3-Figure5-1.png",
      "1803.02750v3-Figure9-1.png",
      "1803.02750v3-Figure10-1.png",
      "1803.02750v3-TableIII-1.png",
      "1803.02750v3-TableIV-1.png",
      "1803.02750v3-Figure12-1.png"
    ],
    "answer": "Delta-based synchronization of a GSet with 2 replicas A,B \u2208 I. Underlined elements represent the BP optimization. <s>"
  },
  "3": {
    "question": "What is the role of the RR optimization in the delta-based synchronization of a GSet?",
    "ground_truth": "The RR optimization helps to reduce the number of messages that need to be exchanged between replicas.",
    "selected_figures": [
      "1803.02750v3-Figure1-1.png",
      "1803.02750v3-TableI-1.png",
      "1803.02750v3-Figure6-1.png",
      "1803.02750v3-Figure7-1.png",
      "1803.02750v3-Figure13-1.png",
      "1803.02750v3-Figure2-1.png",
      "1803.02750v3-Figure3-1.png",
      "1803.02750v3-Figure8-1.png",
      "1803.02750v3-Figure4-1.png",
      "1803.02750v3-Figure5-1.png",
      "1803.02750v3-Figure9-1.png",
      "1803.02750v3-Figure10-1.png",
      "1803.02750v3-TableII-1.png",
      "1803.02750v3-TableIII-1.png",
      "1803.02750v3-TableIV-1.png",
      "1803.02750v3-Figure12-1.png"
    ],
    "answer": "The RR optimization is used in the delta-based synchronization of a GSet. <s>"
  },
  "4": {
    "question": "How does the average metadata required per node for the Op-based BP+RR approach change as the number of nodes in the network increases?",
    "ground_truth": "The average metadata required per node for the Op-based BP+RR approach increases as the number of nodes in the network increases.",
    "selected_figures": [
      "1803.02750v3-Figure1-1.png",
      "1803.02750v3-TableI-1.png",
      "1803.02750v3-Figure6-1.png",
      "1803.02750v3-Figure7-1.png",
      "1803.02750v3-Figure13-1.png",
      "1803.02750v3-Figure2-1.png",
      "1803.02750v3-Figure3-1.png",
      "1803.02750v3-Figure8-1.png",
      "1803.02750v3-Figure4-1.png",
      "1803.02750v3-Figure5-1.png",
      "1803.02750v3-Figure9-1.png",
      "1803.02750v3-Figure10-1.png",
      "1803.02750v3-TableII-1.png",
      "1803.02750v3-TableIII-1.png",
      "1803.02750v3-TableIV-1.png",
      "1803.02750v3-Figure12-1.png"
    ],
    "answer": "The average metadata required per node for the Op-based BP+RR approach increases as the number of nodes in the network increases. <s>"
  },
  "5": {
    "question": "Which algorithm performs the best in terms of average memory ratio with respect to BP+RR for GMap 10%?",
    "ground_truth": "Delta-based BP+RR",
    "selected_figures": [
      "1803.02750v3-Figure1-1.png",
      "1803.02750v3-TableI-1.png",
      "1803.02750v3-Figure7-1.png",
      "1803.02750v3-Figure13-1.png",
      "1803.02750v3-Figure2-1.png",
      "1803.02750v3-Figure3-1.png",
      "1803.02750v3-Figure8-1.png",
      "1803.02750v3-Figure4-1.png",
      "1803.02750v3-Figure5-1.png",
      "1803.02750v3-Figure9-1.png",
      "1803.02750v3-Figure10-1.png",
      "1803.02750v3-TableII-1.png",
      "1803.02750v3-TableIII-1.png",
      "1803.02750v3-TableIV-1.png",
      "1803.02750v3-Figure12-1.png"
    ],
    "answer": "The algorithm that performs the best in terms of average memory ratio with respect to BP+RR for GMap 10% is Delta-based synchronization of a GSet with 4 replicas A,B,C,D \u2208 I. The overlined element represents the RR optimization. <s>"
  },
  "6": {
    "question": "What is the difference between the `inc_i(p)` and `inc_i'(p)` operations in the Grow-only Counter data type?",
    "ground_truth": "The `inc_i(p)` operation increments the value associated with the key `i` in the counter `p`, while the `inc_i'(p)` operation increments the value associated with the key `i` in the counter `p` only if the key `i` is not already present in the counter.",
    "selected_figures": [
      "1803.02750v3-Figure1-1.png",
      "1803.02750v3-TableI-1.png",
      "1803.02750v3-Figure6-1.png",
      "1803.02750v3-Figure7-1.png",
      "1803.02750v3-Figure13-1.png",
      "1803.02750v3-Figure2-1.png",
      "1803.02750v3-Figure3-1.png",
      "1803.02750v3-Figure8-1.png",
      "1803.02750v3-Figure4-1.png",
      "1803.02750v3-Figure5-1.png",
      "1803.02750v3-Figure9-1.png",
      "1803.02750v3-Figure10-1.png",
      "1803.02750v3-TableII-1.png",
      "1803.02750v3-TableIII-1.png",
      "1803.02750v3-TableIV-1.png",
      "1803.02750v3-Figure12-1.png"
    ],
    "answer": "The difference between the `inc_i(p)` and `inc_i'(p)` operations in the Grow-only Counter data type is that `inc_i(p)` increments the value of the counter by 1, while `inc_i'(p)` increments the value of the counter by 2. <s>"
  },
  "7": {
    "question": "Which topology has the highest transmission rate for GMap 100%?",
    "ground_truth": "Mesh",
    "selected_figures": [
      "1803.02750v3-Figure1-1.png",
      "1803.02750v3-TableI-1.png",
      "1803.02750v3-Figure6-1.png",
      "1803.02750v3-Figure7-1.png",
      "1803.02750v3-Figure13-1.png",
      "1803.02750v3-Figure2-1.png",
      "1803.02750v3-Figure3-1.png",
      "1803.02750v3-Figure8-1.png",
      "1803.02750v3-Figure4-1.png",
      "1803.02750v3-Figure5-1.png",
      "1803.02750v3-Figure9-1.png",
      "1803.02750v3-Figure10-1.png",
      "1803.02750v3-TableIII-1.png",
      "1803.02750v3-TableIV-1.png",
      "1803.02750v3-Figure12-1.png"
    ],
    "answer": "The mesh topology has the highest transmission rate for GMap 100%. <s>"
  },
  "8": {
    "question": "If a user with 100 followers posts a tweet, how many CRDT updates will be performed in total, and what percentage of the overall workload does this represent?",
    "ground_truth": "Posting a tweet will result in 1 + 100 = 101 CRDT updates. This represents 35% of the overall workload.",
    "selected_figures": [
      "1803.02750v3-TableI-1.png",
      "1803.02750v3-Figure6-1.png",
      "1803.02750v3-Figure7-1.png",
      "1803.02750v3-Figure13-1.png",
      "1803.02750v3-Figure2-1.png",
      "1803.02750v3-Figure3-1.png",
      "1803.02750v3-Figure8-1.png",
      "1803.02750v3-Figure4-1.png",
      "1803.02750v3-Figure5-1.png",
      "1803.02750v3-Figure9-1.png",
      "1803.02750v3-Figure10-1.png",
      "1803.02750v3-TableII-1.png",
      "1803.02750v3-TableIII-1.png",
      "1803.02750v3-TableIV-1.png",
      "1803.02750v3-Figure12-1.png"
    ],
    "answer": "The number of CRDT updates that will be performed in total for a user with 100 followers posting a tweet is 100, and this represents 100% of the overall workload. <s>"
  },
  "9": {
    "question": "If we use the lexicographic product with a chain as the first component and a distributive lattice as the second component to design a CRDT, will the resulting CRDT lattice be guaranteed to be distributive and satisfy the descending chain condition (DCC)?",
    "ground_truth": "Yes, the resulting CRDT lattice will be guaranteed to be both distributive and satisfy the DCC.",
    "selected_figures": [
      "1803.02750v3-Figure1-1.png",
      "1803.02750v3-TableI-1.png",
      "1803.02750v3-Figure6-1.png",
      "1803.02750v3-Figure7-1.png",
      "1803.02750v3-Figure13-1.png",
      "1803.02750v3-Figure2-1.png",
      "1803.02750v3-Figure3-1.png",
      "1803.02750v3-Figure8-1.png",
      "1803.02750v3-Figure4-1.png",
      "1803.02750v3-Figure5-1.png",
      "1803.02750v3-Figure9-1.png",
      "1803.02750v3-Figure10-1.png",
      "1803.02750v3-TableII-1.png",
      "1803.02750v3-TableIII-1.png",
      "1803.02750v3-TableIV-1.png",
      "1803.02750v3-Figure12-1.png"
    ],
    "answer": "No, the resulting CRDT lattice will not be guaranteed to be distributive and satisfy the descending chain condition (DCC) by using the lexicographic product with a chain as the first component and a distributive lattice as the second component to design a CRDT. <s>"
  },
  "10": {
    "question": "How does the CPU overhead of classic delta-based compare to delta-based BP+RR as the Zipf coefficient increases?",
    "ground_truth": "The CPU overhead of classic delta-based is consistently higher than that of delta-based BP+RR as the Zipf coefficient increases.",
    "selected_figures": [
      "1803.02750v3-Figure1-1.png",
      "1803.02750v3-TableI-1.png",
      "1803.02750v3-Figure6-1.png",
      "1803.02750v3-Figure7-1.png",
      "1803.02750v3-Figure13-1.png",
      "1803.02750v3-Figure2-1.png",
      "1803.02750v3-Figure3-1.png",
      "1803.02750v3-Figure8-1.png",
      "1803.02750v3-Figure4-1.png",
      "1803.02750v3-Figure5-1.png",
      "1803.02750v3-Figure9-1.png",
      "1803.02750v3-Figure10-1.png",
      "1803.02750v3-TableII-1.png",
      "1803.02750v3-TableIII-1.png",
      "1803.02750v3-TableIV-1.png",
      "1803.02750v3-Figure12-1.png"
    ],
    "answer": "The CPU overhead of classic delta-based compared to delta-based BP+RR increases as the Zipf coefficient increases. <s>"
  }
}