{
  "0": {
    "question": "How does batching affect the radio duty cycle and CPU duty cycle?",
    "ground_truth": "Batching reduces both the radio duty cycle and CPU duty cycle.",
    "selected_figures": [
      "1811.02721v3-Table4-1.png",
      "1811.02721v3-Table5-1.png",
      "1811.02721v3-Figure9-1.png",
      "1811.02721v3-Figure10-1.png",
      "1811.02721v3-Table1-1.png",
      "1811.02721v3-Figure3-1.png",
      "1811.02721v3-Figure13-1.png",
      "1811.02721v3-Figure8-1.png",
      "1811.02721v3-Figure7-1.png",
      "1811.02721v3-Figure12-1.png",
      "1811.02721v3-Figure5-1.png",
      "1811.02721v3-Table6-1.png",
      "1811.02721v3-Table2-1.png",
      "1811.02721v3-Table7-1.png",
      "1811.02721v3-Figure11-1.png",
      "1811.02721v3-Figure6-1.png",
      "1811.02721v3-Table8-1.png",
      "1811.02721v3-Table9-1.png",
      "1811.02721v3-Figure1-1.png",
      "1811.02721v3-Table3-1.png"
    ],
    "answer": "Batching can affect the radio duty cycle and CPU duty cycle by reducing the number of packets that need to be transmitted and processed. This can lead to a lower radio duty cycle, which is the percentage of time the radio is in use, and a lower CPU duty cycle, which is the percentage of time the central processing unit (CPU) is in use.  <s>"
  },
  "1": {
    "question": "Which technique was most effective at reducing memory consumption in both send and receive buffers?",
    "ground_truth": "The \"Resource Constraints\" challenge was addressed with two techniques: \"Zero-Copy Send\" and \"In-Place Reass.\" The first led to a 50% reduction in send buffer memory usage, while the second achieved a 38% reduction in receive buffer memory. Therefore, Zero-Copy Send was slightly more effective in reducing overall memory consumption.",
    "selected_figures": [
      "1811.02721v3-Table4-1.png",
      "1811.02721v3-Table5-1.png",
      "1811.02721v3-Figure9-1.png",
      "1811.02721v3-Figure10-1.png",
      "1811.02721v3-Table1-1.png",
      "1811.02721v3-Figure3-1.png",
      "1811.02721v3-Figure13-1.png",
      "1811.02721v3-Figure8-1.png",
      "1811.02721v3-Figure7-1.png",
      "1811.02721v3-Figure12-1.png",
      "1811.02721v3-Figure5-1.png",
      "1811.02721v3-Table6-1.png",
      "1811.02721v3-Table2-1.png",
      "1811.02721v3-Table7-1.png",
      "1811.02721v3-Figure11-1.png",
      "1811.02721v3-Figure6-1.png",
      "1811.02721v3-Table8-1.png",
      "1811.02721v3-Table9-1.png",
      "1811.02721v3-Figure1-1.png",
      "1811.02721v3-Table3-1.png"
    ],
    "answer": "The technique that was most effective at reducing memory consumption in both send and receive buffers was the implementation of TCPlp on RIOT OS, which spans three modules: (1) protocol implementation, (2) event scheduler that injects callbacks into userspace, and (3) userland library. <s>"
  },
  "2": {
    "question": "Based on Table 1 and the passage, why does TCP perform poorly on IEEE 802.15.4 networks compared to other network types listed? ",
    "ground_truth": "TCP performs poorly on IEEE 802.15.4 networks because the Maximum Transmission Unit (MTU) for these networks is significantly smaller than other network types. This small MTU size results in a high percentage of overhead due to the TCP/IP headers, exceeding 50%. ",
    "selected_figures": [
      "1811.02721v3-Table4-1.png",
      "1811.02721v3-Table5-1.png",
      "1811.02721v3-Figure9-1.png",
      "1811.02721v3-Figure10-1.png",
      "1811.02721v3-Table1-1.png",
      "1811.02721v3-Figure3-1.png",
      "1811.02721v3-Figure13-1.png",
      "1811.02721v3-Figure8-1.png",
      "1811.02721v3-Figure7-1.png",
      "1811.02721v3-Figure12-1.png",
      "1811.02721v3-Figure5-1.png",
      "1811.02721v3-Table6-1.png",
      "1811.02721v3-Table2-1.png",
      "1811.02721v3-Table7-1.png",
      "1811.02721v3-Figure11-1.png",
      "1811.02721v3-Figure6-1.png",
      "1811.02721v3-Table8-1.png",
      "1811.02721v3-Table9-1.png",
      "1811.02721v3-Figure1-1.png",
      "1811.02721v3-Table3-1.png"
    ],
    "answer": "TCP (Transmission Control Protocol) performs poorly on IEEE 802.15.4 networks compared to other network types listed, such as Ethernet and Wi-Fi, due to the high radio duty cycle (RDC) in a lossy wireless environment. <s>"
  },
  "3": {
    "question": "Why is relying on fragmentation effective for reducing header overhead?",
    "ground_truth": "Relying on fragmentation is effective because the TCP/IP headers are only included in the first fragment, not in subsequent fragments. This significantly reduces the overhead in later fragments.",
    "selected_figures": [
      "1811.02721v3-Table4-1.png",
      "1811.02721v3-Table5-1.png",
      "1811.02721v3-Figure9-1.png",
      "1811.02721v3-Figure10-1.png",
      "1811.02721v3-Table1-1.png",
      "1811.02721v3-Figure3-1.png",
      "1811.02721v3-Figure13-1.png",
      "1811.02721v3-Figure8-1.png",
      "1811.02721v3-Figure7-1.png",
      "1811.02721v3-Figure12-1.png",
      "1811.02721v3-Figure5-1.png",
      "1811.02721v3-Table6-1.png",
      "1811.02721v3-Table2-1.png",
      "1811.02721v3-Table7-1.png",
      "1811.02721v3-Figure11-1.png",
      "1811.02721v3-Figure6-1.png",
      "1811.02721v3-Table8-1.png",
      "1811.02721v3-Table9-1.png",
      "1811.02721v3-Figure1-1.png",
      "1811.02721v3-Table3-1.png"
    ],
    "answer": "Fragmentation is an effective way to reduce header overhead because it splits large packets into smaller, more manageable chunks that can be transmitted more efficiently over the network. This reduces the amount of data that needs to be transmitted, which in turn reduces the size of the header required to encapsulate the data. By reducing the header size, the overall overhead of the transmission is reduced, making it more efficient and cost-effective. <s>"
  },
  "4": {
    "question": "How does varying the buffer size affect TCP goodput?",
    "ground_truth": "Increasing the buffer size generally leads to increased TCP goodput, but only up to a certain point.",
    "selected_figures": [
      "1811.02721v3-Table4-1.png",
      "1811.02721v3-Table5-1.png",
      "1811.02721v3-Figure9-1.png",
      "1811.02721v3-Figure10-1.png",
      "1811.02721v3-Table1-1.png",
      "1811.02721v3-Figure3-1.png",
      "1811.02721v3-Figure13-1.png",
      "1811.02721v3-Figure8-1.png",
      "1811.02721v3-Figure7-1.png",
      "1811.02721v3-Figure12-1.png",
      "1811.02721v3-Figure5-1.png",
      "1811.02721v3-Table6-1.png",
      "1811.02721v3-Table2-1.png",
      "1811.02721v3-Table7-1.png",
      "1811.02721v3-Figure11-1.png",
      "1811.02721v3-Figure6-1.png",
      "1811.02721v3-Table8-1.png",
      "1811.02721v3-Table9-1.png",
      "1811.02721v3-Figure1-1.png",
      "1811.02721v3-Table3-1.png"
    ],
    "answer": "Varying the buffer size affects TCP goodput by changing the amount of data that can be buffered in the network interface controller (NIC) before it is sent to the network. A larger buffer size allows for more data to be buffered, resulting in a lower radio duty cycle (RDC) and improved TCP goodput.  <s>"
  },
  "5": {
    "question": "What is the function of the Hamilton-based PCB in the ultrasonic anemometer?",
    "ground_truth": "The Hamilton-based PCB is the electronic control board of the anemometer. It houses the microcontroller, sensors, and other electronic components that are necessary for the anemometer to function.",
    "selected_figures": [
      "1811.02721v3-Table4-1.png",
      "1811.02721v3-Table5-1.png",
      "1811.02721v3-Figure9-1.png",
      "1811.02721v3-Figure10-1.png",
      "1811.02721v3-Table1-1.png",
      "1811.02721v3-Figure3-1.png",
      "1811.02721v3-Figure13-1.png",
      "1811.02721v3-Figure8-1.png",
      "1811.02721v3-Figure7-1.png",
      "1811.02721v3-Figure12-1.png",
      "1811.02721v3-Figure5-1.png",
      "1811.02721v3-Table6-1.png",
      "1811.02721v3-Table2-1.png",
      "1811.02721v3-Table7-1.png",
      "1811.02721v3-Figure11-1.png",
      "1811.02721v3-Figure6-1.png",
      "1811.02721v3-Table8-1.png",
      "1811.02721v3-Table9-1.png",
      "1811.02721v3-Figure1-1.png",
      "1811.02721v3-Table3-1.png"
    ],
    "answer": "The function of the Hamilton-based PCB in the ultrasonic anemometer is to measure wind speed and direction. <s>"
  },
  "6": {
    "question": "What is the difference in response time between CoAP and HTTP for a response size of 50 KiB?",
    "ground_truth": "The difference in response time between CoAP and HTTP for a response size of 50 KiB is approximately 20 seconds.",
    "selected_figures": [
      "1811.02721v3-Table4-1.png",
      "1811.02721v3-Table5-1.png",
      "1811.02721v3-Figure9-1.png",
      "1811.02721v3-Figure10-1.png",
      "1811.02721v3-Table1-1.png",
      "1811.02721v3-Figure3-1.png",
      "1811.02721v3-Figure13-1.png",
      "1811.02721v3-Figure8-1.png",
      "1811.02721v3-Figure7-1.png",
      "1811.02721v3-Figure12-1.png",
      "1811.02721v3-Figure5-1.png",
      "1811.02721v3-Table6-1.png",
      "1811.02721v3-Table2-1.png",
      "1811.02721v3-Table7-1.png",
      "1811.02721v3-Figure11-1.png",
      "1811.02721v3-Figure6-1.png",
      "1811.02721v3-Table8-1.png",
      "1811.02721v3-Table9-1.png",
      "1811.02721v3-Figure1-1.png",
      "1811.02721v3-Table3-1.png"
    ],
    "answer": "The difference in response time between CoAP and HTTP for a response size of 50 KiB is negligible. <s>"
  },
  "7": {
    "question": "How does the maximum link delay affect the segment loss rate and goodput in a TCP connection with one hop?",
    "ground_truth": "As the maximum link delay increases, the segment loss rate increases and the goodput decreases.",
    "selected_figures": [
      "1811.02721v3-Table4-1.png",
      "1811.02721v3-Table5-1.png",
      "1811.02721v3-Figure9-1.png",
      "1811.02721v3-Figure10-1.png",
      "1811.02721v3-Table1-1.png",
      "1811.02721v3-Figure3-1.png",
      "1811.02721v3-Figure8-1.png",
      "1811.02721v3-Figure7-1.png",
      "1811.02721v3-Figure12-1.png",
      "1811.02721v3-Figure5-1.png",
      "1811.02721v3-Table6-1.png",
      "1811.02721v3-Table2-1.png",
      "1811.02721v3-Table7-1.png",
      "1811.02721v3-Figure11-1.png",
      "1811.02721v3-Figure6-1.png",
      "1811.02721v3-Table8-1.png",
      "1811.02721v3-Table9-1.png",
      "1811.02721v3-Figure1-1.png",
      "1811.02721v3-Table3-1.png"
    ],
    "answer": "The maximum link delay affects the segment loss rate and goodput in a TCP connection with one hop by limiting the amount of time that packets can be held up in transit. If the link delay is too high, packets may be dropped or delayed to the point where they are no longer useful for the connection. This can result in a higher segment loss rate and lower goodput. <s>"
  },
  "8": {
    "question": "What protocol has a higher radio duty cycle in the first 7 hours of the trial?",
    "ground_truth": "TCP",
    "selected_figures": [
      "1811.02721v3-Table4-1.png",
      "1811.02721v3-Table5-1.png",
      "1811.02721v3-Figure9-1.png",
      "1811.02721v3-Figure10-1.png",
      "1811.02721v3-Table1-1.png",
      "1811.02721v3-Figure3-1.png",
      "1811.02721v3-Figure13-1.png",
      "1811.02721v3-Figure8-1.png",
      "1811.02721v3-Figure7-1.png",
      "1811.02721v3-Figure12-1.png",
      "1811.02721v3-Figure5-1.png",
      "1811.02721v3-Table6-1.png",
      "1811.02721v3-Table2-1.png",
      "1811.02721v3-Table7-1.png",
      "1811.02721v3-Figure11-1.png",
      "1811.02721v3-Figure6-1.png",
      "1811.02721v3-Table8-1.png",
      "1811.02721v3-Table9-1.png",
      "1811.02721v3-Figure1-1.png",
      "1811.02721v3-Table3-1.png"
    ],
    "answer": "TCP has a higher radio duty cycle in the first 7 hours of the trial. <s>"
  },
  "9": {
    "question": "How does the maximum link delay affect the number of TCP timeouts and fast retransmissions?",
    "ground_truth": "The number of TCP timeouts and fast retransmissions decreases as the maximum link delay increases.",
    "selected_figures": [
      "1811.02721v3-Table4-1.png",
      "1811.02721v3-Table5-1.png",
      "1811.02721v3-Figure9-1.png",
      "1811.02721v3-Figure10-1.png",
      "1811.02721v3-Table1-1.png",
      "1811.02721v3-Figure3-1.png",
      "1811.02721v3-Figure13-1.png",
      "1811.02721v3-Figure8-1.png",
      "1811.02721v3-Figure7-1.png",
      "1811.02721v3-Figure12-1.png",
      "1811.02721v3-Figure5-1.png",
      "1811.02721v3-Table6-1.png",
      "1811.02721v3-Table2-1.png",
      "1811.02721v3-Table7-1.png",
      "1811.02721v3-Figure11-1.png",
      "1811.02721v3-Figure6-1.png",
      "1811.02721v3-Table8-1.png",
      "1811.02721v3-Table9-1.png",
      "1811.02721v3-Figure1-1.png",
      "1811.02721v3-Table3-1.png"
    ],
    "answer": "The maximum link delay affects the number of TCP timeouts and fast retransmissions by limiting the amount of time that packets can take to travel through the network. If the link delay is too high, packets may be lost or delayed, leading to an increased number of timeouts and retransmissions. <s>"
  },
  "10": {
    "question": "Which module of TCPlp consumes the most memory in the active RAM on TinyOS, and how much memory does it utilize?",
    "ground_truth": "The protocol implementation module consumes the most memory in the active RAM on TinyOS, utilizing 488 bytes.",
    "selected_figures": [
      "1811.02721v3-Table4-1.png",
      "1811.02721v3-Table5-1.png",
      "1811.02721v3-Figure9-1.png",
      "1811.02721v3-Figure10-1.png",
      "1811.02721v3-Table1-1.png",
      "1811.02721v3-Figure3-1.png",
      "1811.02721v3-Figure13-1.png",
      "1811.02721v3-Figure8-1.png",
      "1811.02721v3-Figure7-1.png",
      "1811.02721v3-Figure12-1.png",
      "1811.02721v3-Figure5-1.png",
      "1811.02721v3-Table6-1.png",
      "1811.02721v3-Table2-1.png",
      "1811.02721v3-Table7-1.png",
      "1811.02721v3-Figure11-1.png",
      "1811.02721v3-Figure6-1.png",
      "1811.02721v3-Table8-1.png",
      "1811.02721v3-Table9-1.png",
      "1811.02721v3-Figure1-1.png",
      "1811.02721v3-Table3-1.png"
    ],
    "answer": "The TCPlp protocol module consumes the most memory in the active RAM on TinyOS, and it utilizes approximately 1.5 kilobytes (KB) of memory. <s>"
  },
  "11": {
    "question": "How does the reliability of CoAP compare to TCPlp and what potential factors contribute to this difference?",
    "ground_truth": "Table 1 shows that CoAP has slightly higher reliability (99.5%) compared to TCPlp (99.3%). While both protocols perform well, this difference could be attributed to several factors, including:\n\nRetransmission mechanisms: CoAP employs a built-in retransmission mechanism for lost packets, while TCPlp relies on the underlying network layer for retransmissions. This could give CoAP an edge in recovering lost packets and achieving higher reliability.\nCongestion control: CoAP includes mechanisms to adapt to network congestion, potentially reducing packet loss and improving reliability.\nPacket size: CoAP typically uses smaller packets compared to TCPlp. Smaller packets are less prone to loss in wireless networks, potentially contributing to CoAP's slightly higher reliability.",
    "selected_figures": [
      "1811.02721v3-Table4-1.png",
      "1811.02721v3-Table5-1.png",
      "1811.02721v3-Figure9-1.png",
      "1811.02721v3-Figure10-1.png",
      "1811.02721v3-Table1-1.png",
      "1811.02721v3-Figure3-1.png",
      "1811.02721v3-Figure13-1.png",
      "1811.02721v3-Figure8-1.png",
      "1811.02721v3-Figure7-1.png",
      "1811.02721v3-Figure12-1.png",
      "1811.02721v3-Figure5-1.png",
      "1811.02721v3-Table6-1.png",
      "1811.02721v3-Table2-1.png",
      "1811.02721v3-Table7-1.png",
      "1811.02721v3-Figure11-1.png",
      "1811.02721v3-Figure6-1.png",
      "1811.02721v3-Table8-1.png",
      "1811.02721v3-Table9-1.png",
      "1811.02721v3-Figure1-1.png",
      "1811.02721v3-Table3-1.png"
    ],
    "answer": "The reliability of Constrained Application Protocol (CoAP) is generally lower than that of Tiny Contiki Link Layer Protocol (TCPlp) in a lossy wireless environment. Factors contributing to this difference include CoAP's use of the User Datagram Protocol (UDP) as its transport layer, which is less reliable than the Transmission Control Protocol (TCP) used by TCPlp. Additionally, CoAP's congestion control mechanism is less sophisticated than TCPlp's, leading to a higher likelihood of congestion and"
  },
  "12": {
    "question": "How does the memory usage of the RIOT OS posix_sockets module compare to the memory used by the protocol and socket layer combined, for both active and passive connections?",
    "ground_truth": "The posix_sockets module consistently uses less memory than the combined usage of the protocol and socket layer. For an active connection, it requires about 5468 B compared to 19972 B + 6216 B = 26188 B for the other layers. Similarly, for a passive connection, it uses 5468 B compared to 19972 B + 6216 B = 26188 B for the other layers.",
    "selected_figures": [
      "1811.02721v3-Table4-1.png",
      "1811.02721v3-Table5-1.png",
      "1811.02721v3-Figure9-1.png",
      "1811.02721v3-Figure10-1.png",
      "1811.02721v3-Table1-1.png",
      "1811.02721v3-Figure3-1.png",
      "1811.02721v3-Figure13-1.png",
      "1811.02721v3-Figure8-1.png",
      "1811.02721v3-Figure7-1.png",
      "1811.02721v3-Figure12-1.png",
      "1811.02721v3-Figure5-1.png",
      "1811.02721v3-Table6-1.png",
      "1811.02721v3-Table2-1.png",
      "1811.02721v3-Table7-1.png",
      "1811.02721v3-Figure11-1.png",
      "1811.02721v3-Figure6-1.png",
      "1811.02721v3-Table8-1.png",
      "1811.02721v3-Table9-1.png",
      "1811.02721v3-Figure1-1.png",
      "1811.02721v3-Table3-1.png"
    ],
    "answer": "The memory usage of the RIOT OS posix\\_sockets module is higher than the memory used by the protocol and socket layer combined, for both active and passive connections. <s>"
  },
  "13": {
    "question": "Which TCP stack provides the most complete implementation of core TCP features, and which stack lacks the most features?",
    "ground_truth": "The TCP stack presented in this paper (TCPlp) provides the most complete implementation of core TCP features, including flow control, congestion control, RTT estimation, MSS option, OOO reassembly, and various advanced features like timestamps and selective ACKs. In contrast, BLIP lacks the most features, as it does not implement congestion control, RTT estimation, or several other functionalities present in other stacks.",
    "selected_figures": [
      "1811.02721v3-Table4-1.png",
      "1811.02721v3-Table5-1.png",
      "1811.02721v3-Figure9-1.png",
      "1811.02721v3-Figure10-1.png",
      "1811.02721v3-Table1-1.png",
      "1811.02721v3-Figure3-1.png",
      "1811.02721v3-Figure8-1.png",
      "1811.02721v3-Figure7-1.png",
      "1811.02721v3-Figure12-1.png",
      "1811.02721v3-Figure5-1.png",
      "1811.02721v3-Table6-1.png",
      "1811.02721v3-Table2-1.png",
      "1811.02721v3-Table7-1.png",
      "1811.02721v3-Figure11-1.png",
      "1811.02721v3-Figure6-1.png",
      "1811.02721v3-Table8-1.png",
      "1811.02721v3-Table9-1.png",
      "1811.02721v3-Figure1-1.png",
      "1811.02721v3-Table3-1.png"
    ],
    "answer": "The stack that provides the most complete implementation of core TCP features is BLIP (TinyOS), while the stack that lacks the most features is GNRC (RIOT). <s>"
  },
  "14": {
    "question": "How many hops are there between the Hamilton and the Internet?",
    "ground_truth": "5 hops",
    "selected_figures": [
      "1811.02721v3-Table4-1.png",
      "1811.02721v3-Figure9-1.png",
      "1811.02721v3-Figure10-1.png",
      "1811.02721v3-Table1-1.png",
      "1811.02721v3-Figure3-1.png",
      "1811.02721v3-Figure13-1.png",
      "1811.02721v3-Figure8-1.png",
      "1811.02721v3-Figure7-1.png",
      "1811.02721v3-Figure12-1.png",
      "1811.02721v3-Figure5-1.png",
      "1811.02721v3-Table6-1.png",
      "1811.02721v3-Table2-1.png",
      "1811.02721v3-Table7-1.png",
      "1811.02721v3-Figure11-1.png",
      "1811.02721v3-Figure6-1.png",
      "1811.02721v3-Table8-1.png",
      "1811.02721v3-Table9-1.png",
      "1811.02721v3-Figure1-1.png",
      "1811.02721v3-Table3-1.png"
    ],
    "answer": "There are 5 hops between the Hamilton and the Internet in the snapshot of uplink routes in OpenThread topology at transmission power of -8 dBm (5 hops). <s>"
  }
}